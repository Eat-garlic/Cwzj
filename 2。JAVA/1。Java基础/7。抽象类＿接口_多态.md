# 抽象 类：

- 抽象类用ａｂｓｔｒａｃｔｇ来修饰 
- 抽象类不能实例化，可以有构造方法，构造方法是给子类来实例化的，因为子类的初始化一定要先调用父类的构造方法
- 抽象 类中的抽象方法没有方法体，且子类继承抽象类时，必须要实现所有的抽象方法
- 抽象 类中的方法，权限不能用ｐｒｉｖａｔｅ去修饰，因为抽象 类定义出来的的意义就是子类去实现的

![image-20240202162446843](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162447.png)

抽取两个类的公共代码，两个类的一些特定的实现，我们可以用用抽象类来弄一个抽象 方法，让他们各自去实现自己的特定代码， 这样就起到了一个极致抽取的效果  这也是抽象类的意义所在





# **接口：**

接口：是一组抽象方法的组合，用interface关键字来表示 ，

- 接口中可以定义抽象方法，常量，默认方法，嵌套类型，public可以省，常量可以省static final，从java9开始，接口中可以定义私有的方法，
- 接口是用来定义一个功能的，某个接口，其中有什么方法，代表这个接口可以具备什么方法
- 接口是用来实现的，一个类实现某个接口，必须 要实现接口中的所有抽象 方法
- 类可以实现多个接口，但只能有一个继承 ，多实现，单继承
- 不能定义抽象方法，不能定义初始化块，不能实例化
- 多个父接口方法签名一样时，那么返回值类型也必须一样

**接口升级问题：**

如果接口中写了固定的方法，有一百个类实现了这个接口，此时 我想再加入一些功能，可能需要重新定义了两个新的抽象方法，让子类去实现， 因为接口中的抽象方法必须子类必须要实现，就会出现 这一百个类都需要去实现这两个方法，这一百个类都会变更， 这样牵一发而动全身，不行

为了解决这个接口升级的问题：有两种方法可以解决

- 默认方法
- 静态方法

**1。默认方法**

默认方法：我们可以在接口中default写个默认方法，默认方法和一般方法的书写格式都一样，在默认方法里面写上我们需要添加的功能，这样就完成了接口功能升级的问题。

默认方法需要注意的细节，

​     \- 当父类中的方法和接口中的默认方法一样时，此时必须要实现这个父类的方法，如果想要调用接口中默认的实现可以用       “接口名.super.默认方法”     

![image-20240202162505044](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162505.png)

-如果实现了多个接口，且接口中的默认方法是一样的，那么实现类必须要实现每个接口中相同的方法      ----因为如果我实现类不实现的话，那我调用这个相同的方法时会出现岐义

![image-20240202162523138](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162523.png)

**2。静态方法**

静态方法，接口中的静态方法可以理解为方法的修饰体在方法区中，值在静态域中， 只有一份内存，不存储被继承，一个类实现了这个接口，这个静态方法也只能通过接口名来调用

![image-20240202162541095](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162541.png)

在接口中添加想要 升级功能的静态方法，然后在一百多个类中直接去调用那唯一一份的内存静态方法，也能达到接口升级的效果



# **多态**

我们New出来的对象一般都是有一个引用变量在栈空间中去引用堆中的对象内存，当一个类继承了另一个类时，我们用父类的类型变量指向子类类型的内存，在调用时，调用的是子类的类型，这种情况我们就称为多态，根据jvm具体调用的对象内存来调用其方法，父类（接口）类型指向子类对象，调用子类重写的方法，不能调用子类除重写方法之外的其他方法



![image-20240202162558340](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162558.png)

![image-20240202162613560](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162613.png)





![image-20230216120821239](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20230216120821.png)





多态变量指向子类变量时，静态类方法调用跟随 左边类型

![image-20240202162814159](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162814.png)







## 多态的理解 

父亲类的方法 调用 调不到， 不会无缘无故的调用子类的同名方法  

什么 情况下可以调到子类的方法 ，有两个前提 

 前提1：父类的引用 指向了子类，

前提2：且子类重写了父类被调用的方法 









# **instanceof关键字**

判断 一个对象是否属于一个类型（父类，或者，接口类型）    object instanceof  xxx.class

![image-20240202162832246](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202162832.png)



Object instanceof  xxx.class：    （ 用来测试一个对象是否为一个类的实例）







左边是对象，右边是类或者一个接口；当对象是右边类或子类，或者是其接口的实现类，返回true；否则，返false。
！！！：类的实例包含本身的实例，以及所有直接或间接子类的实例
instanceof左边显式声明的类型与右边操作元必须是同种类型（接口也算）或存在继承关系，也就是说需要位于同一个继承，否则会编译错误



注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。

通过注意，我们可以知道 想要让编译器不摄氏， 就要转为class类型



![image-20230216151221171](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20230216151221.png)







当把子类对象赋给父类引用变量时，这个父类引用变量只能调用父类拥有的方法，不能调用子类特有的方法，即使它实际引用的是子类对象。
如果需要让这个父类引用变量调用它子类的特有的方法，就必须把它强制转换成子类类型。



2.引用类型之间要强制转换成功需要有什么条件
把父类实例转换成子类类型，则这个对象必须实际上是子类实例才行，否则将在运行时引发ClassCastException。











# **对象数组 的注意点**

![image-20240202163007063](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240202163007.png)



因为obj类型是integer类型的父类，可以强制将obj转为小的子类类型，然后调用子类的资源

而object数组和integer数组两者之间没有子父类关系，所以这样强转会报类型错误








