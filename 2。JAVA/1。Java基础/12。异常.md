

# 概念

## 【编译器就是我】要把自己当成编译器游走在字节码文件之中，这样会更好的理解比如一个.class文件，我在扫描准备编译时，发现了扫描不通，就称之为异常





当程序在运行的过程中出现了错误，我们就称为异常。异常是java系统自带的一个机制，当程序写好时，在运行的时候因为异常，导致程序退出的整个过程就称为异常 

我们在写程序时要尽量避免异常的发生，程序写好了跑不起来出现错误，耽误的是公司的项目进度，耽误的是公司的收入来源，我们将项目交给使用者的时候出现了异常程序退出，使用者不会给钱给公司，所以写程序时一定要避免异常，

怎样有效的避免呢，jvm在运行程序 的时候有一套自己的异常机制， jdk中有自带的异常相关类，当代码出现了异常，jvm系统 会自己生产出一个异常的对象，这个对象是系统 自己生产的，无需我们多管，每段代码出现了异常都会产生出一个对应类型的异常对象，

这个对象交给jvm运行时环境，此时运行时环境去找有没有处理这个异常对应相应的代码，如果有就将这段出现问题的代码交给处理这个异常代码的代码块去执行，如果没有，程序 就会终止，jvm退出 

异常不处理，程序便会退出 

## 检查型和非检查型的深理解



![image-20240204082013227](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204082013.png)







# **异常的分类：**



![image-20220507145008575](https://raw.githubusercontent.com/jinkex55/picture/master/images20220507145008.png)那么在jdk中，程序出现异常的类型都包含在这些类中，可以理解程序 出现 的异常大部分可以用Jdk 中自带的异常类型来概括

![image-20240204082053921](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204082054.png)



## **检查型异常：**

​     编译器自己就能发现的错误就是检查型异常，当我程序开发者去强制处理，不处理编译器就不报错的异常 ，无论开发者做了多少年开发，代码写的多Nb，都可能 发生的异常，称为检查型异常，

```
Intdsfsa  a   =   1;
```



这个代码，编译器报错，识别不到有int...这个类型，要求我们必须去处理，这个是语法错误，严格意义上讲不是异常，这里我们把它当异常有便于我们理解，

当我在扫描源代码.class文件时，如果出现了飘红，必须要开发者去解决的称这为检查型异常，比如

```
Class.froNmae(Com.mj.Dogggg);

```

这个代码会出现 检查型异常，项目中可能没有Dogggg这个类，因为字符串是参数，使用者传进来的，所以我们没法去避免，编译器在检查 这行字节码时，会去扫描项目中是否有这个文件，当然有没有它一定是知道的，如果有更好，没有的话，编译不通过，扫描不成功

类似于这些性质的我们可以称为是检查 型异常

## **非检查型异常**

字节码成功的通过扫描，编译器觉得没有错误的，但在运行的过程中可能 会出现一些逻辑错误的，编译器管不了了，这些称为非检查异常 

```
Long [] b = new Long[1000000000],
```

这个我就没办法判定我的堆是不是足够了，这个就叫非检查异常，







# **异常的处理**	

好了，既然出现了异常，那么我们应该怎样解决异常呢

有两个方法解决异常

## **第一种是，Try catch**

```
try{
    
}catch（e）{
    
}
```

try块中是可能会出现异常的代码，如果 出现异常代码，jvm运行时环境会创建出一个对应异常类型的对象，运行时环境会将这个异常对象去交给catch异常对象e去处理，如果e的类型和出现 的类型是一样的，那么就成功进入这个catch e下面的代码块，成功得到处理

- catch是可以有多个的
- 多个异常对象可以写在同一个（）中，用|号隔开，如果写在同一个（）中，这个e就是隐式final，不能再赋值了
- 当try代码块中出现 了异常try代码块后面的就不执行了，而是执行后面catch后面的代码了

e这个对象是异常对象，我们可以用这个e对象做一些事情 ，我们想要的事情，比如我们可以通过e对象来进行得到这个异常的信息，

```
e.getMeassage();
```

![image-20211120144558052](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204082113.png)





## **第二种处理方法Throws**

当一段代码中出现 了异常，还可以通过throws关键字将这个异常对象扔出去，比如我是隋方法，来调用这段代码，这段代码出现了异常，如果 它自己进行了处理那么我照样运行它的这段代码，不会报错，有可能 出现 两种情况，一种是它不处理，也不扔给我处理，那么程序 会退出 ；第二种情况它扔给我处理，怎样扔呢

```
xxx ()throws e {
    
}
```

扔给了调用它的隋方法去处理，隋方法就接住了这个异常，隋方法将这个异常自己接住了，也有两种方法，第一种：自己catch,第二种，扔出去，可以一直往上扔，扔到程序的入口Main 方法，到了这层，一般就不会再扔了，如果再扔，就扔给了jvm，程序就自行退出了



# **finally**

这个是用来

有些代码方法需要打开资源 ，我如果出现 了异常，资源得不到释放，为了确保资源得到释放，可以将释放资源的代码写到程序必须会走的final中，这样会关闭掉这个资源 

![image-20211120145238025](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204082126.png)



# **对于资源关闭的理解** 

![image-20211120145431288](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204082139.png)







# **自定义异常**

在开发中，我们可以自己定义异常，来实现对一类错误的说明，我们自己写一个类继承 exception或者RuntimeException，这样我们就能，然后调用父类的构造方法，传入一段字符串，在new这个异常对象时，要调用父类的构造方法，然后将字符串打印出来，得到我们想要提示的效果

![image-20211120145558059](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204082323.png)

![image-20211120145610381](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204082501.png)









# 利用学到的异常来写一个断言类





![image-20211120145818941](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204083449.png)