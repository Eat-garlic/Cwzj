# 代理 

在做业务时，想在业务代码上增加一些额外的功能，比如记录下日志，事务，性能监测，异常等，比如dao层我们要在操作数据库后还要进行事务的提交，所以每次在操作数据库时都要进行提交事务，这样我们进行的这块代码里面不是纯业务代码，看起来有累赘，打个比方如果能实现这些事务代码不在业务中，调用方不改代码执行调用方相同的代码能实现之前业务代码效果，额外不动业务代码但是执行结果能有功能增强的效果  的整个过程称之为代理

![image-20220228170942170](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204165835.png)

![](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204165847.png)

![image-20220228171017908](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204165934.png)

## 静态代理

 静态代理的逻辑是  一个目标类在现有的功能下，想额外增加一些功能，在不改变代码的情况下实现

实现这一步需要 调用方调用这个目标类的同时，得出一样的效果

![image-20220228171035441](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20240204165947.png)

### 方法一：代理类和目标类实现同样的接口

我们将代理类和目标类实现同样的接口，这样代理类和目标类都是同一类型的，也能确保代理类中有和目标类一样的方法，这时我们只需要在代理类中注入目标类，将目标类的类型作为代理类的一个引用类型，调用方在调用目标类时，我们只需要在配置文件中将之前注入容器的目标类换成实现相同接口的代理类，id不变（容器一般会认为是同一类型的，因为实现 了相同的接口），然后在代理类中注入目标类，调用代理类和目标类相同的方法，在代理类相同的方法再调回到目标类的相同方法，这时在目标类相同方法  前 后  书写额外功能的代码。这样便实现了静态代理



### 方法二：代理类继承目标类

有些目标类功能比较单一，没有接口，这时想实现和上面的代理效果要怎样呢，直接将代理类继承目标类，重写目标类的方法，调用代理类和目标类相同的方法 ，通过代理类注入目标类的引用，调用到目标类的引用 ，在前后加入增强的代码，便能完成不修改目标类的方法达到效果了。



![image-20221230183325856](https://raw.githubusercontent.com/Eat-garlic/picture/master/images20221230183326.png)







## 动态代理

上面学了动态代理，在很多情况下，如果写很多的模板代码只是为了给我们业务类增加代理功能会 很麻烦，如何做到不需要写代理类就能实现代理的效果，这是我们开发者要考虑的问题，

在这里，我们就引入了动态代理

动态代理在不需要硬盘中的.java文件编译后的字节码文件，就能达到代码的加强功能

之所以能做到这样的效果，是因为动态代理是在程序运行中，程序自己动态的生成代理类的字节码，从而在运行的过程中实现代码的增强。 动态代理 的字节码去哪了呢，是 在程序的运行过程中程序自己生成 的，不需要我们多管





和静态代理一样（只有在理解了静态代理的前提下，才能很好的理解动态代理)

### Jdk动态代理 对应方法一

想了解动态代理，先得了解一下bean的生命周期中的一个方法 ， 

![image-20230203152013440](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20230203152013.png)

对应的是这两个方法

![image-20220506141434910](https://raw.githubusercontent.com/jinkex55/picture/master/images20220506141435.png)





![image-20220506142306621](https://raw.githubusercontent.com/jinkex55/picture/master/images20220506142306.png)





所有的bean都是穿越这两个方法的

这两个方法可以是被自己写的类所实现，通过这个类来穿过，

所以我们在给容器中的bean来写代理时，直接将代理的代码放入生命周期的第8部分，来实现所有bean的代理。

因为bean的生命周期会穿过这些方法 ，所以只需要将我们想要增强的功能在这个周期里面写好，然后运行程序，它自然会执行，



Jdk：

 ```java
Proxy.newInstance(类加载器，接口，附加代码)//三个参数，



 ```

附加代码是通过一个接口类型传进去的





![image-20230203173310139](https://raw.githubusercontent.com/Eat-garlic/picture/master/img/20230203173310.png)









 

###  CGLB代理 对应方法二



